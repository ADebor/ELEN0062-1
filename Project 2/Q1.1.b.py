# IML - Project 2 - Q1.1.b
# (Antoine Debor & Jan Held, November 2020)

import numpy as np
import random
import matplotlib.pyplot as plt
from scipy.stats import multivariate_normal


def multivariate_gaussian_distribution(numberOfPoints):
    """Each sample x_i = (x0_i, x1_i) is generated by first selecting
       its class y_i at random (with an equal probability for each class),
       and then drawing their values from a multivariate Gaussian distribution.
       Returns the generalization error of the Bayes model.

    Parameters
    ----------
    numberOfPoints : int > 0
        The number of points to generate

    Return
    ------
    per : the generalization error of the Bayes model
    """

    x0 = np.empty([numberOfPoints, 1])
    x1 = np.empty([numberOfPoints, 1])
    y = np.empty([numberOfPoints, 1])

    mean = np.matrix([[0], [0]])
    covariancePlus = np.matrix([[1, 0.75], [0.75, 1]])
    covarianceMinus = np.matrix([[1, -0.75], [-0.75, 1]])
    LPlus = np.linalg.cholesky(covariancePlus)
    LMinus = np.linalg.cholesky(covarianceMinus)

    for index in range(numberOfPoints):
        """ True if y+ class
            False if y- class """
        boolean = bool(random.getrandbits(1))
        if(boolean):
            y[index] = 1
            X = np.random.normal(size=(2, 1))
            x0[index], x1[index] = LPlus.dot(X) + mean
        else:
            y[index] = -1
            X = np.random.normal(size=(2, 1))
            x0[index], x1[index] = LMinus.dot(X) + mean

    counter = 0
    for index in range(numberOfPoints):
        if(x0[index] * x1[index] > 0):
            if(y[index] != 1):
                counter += 1
        else:
            if(y[index] != -1):
                counter += 1

    per = counter/numberOfPoints

    return per


def empirically_results(numberOfSets, numberOfPoints):
    """Calculates the average generalization error of the Bayes model

    Parameters
    ----------
    numberOfSets : int > 0
        The number of different sets to generate
    numberOfPoints : int > 0
        The number of points to generate

    Return
    ------
    per : the average generalization error of the Bayes model
    """

    aux = 0
    for i in range(numberOfSets):
         aux += multivariate_gaussian_distribution(numberOfPoints)

    per = aux/numberOfSets
    return per


if __name__ == '__main__':

    numberOfSets = 100
    numberOfPoints = 20000
    random.seed(0)
    np.random.seed(0)

    print(empirically_results(numberOfSets, numberOfPoints))
